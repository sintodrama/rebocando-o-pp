<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="./main.css">
    <script src="https://cdn.jsdelivr.net/npm/resonance-audio/build/resonance-audio.min.js"></script>
</head>
<canvas id="c"></canvas>
<body>
<h1>Rebocando o Pavilh√£o Philips</h1>

    <script type="module">
        import * as THREE from 'https://cdn.rawgit.com/mrdoob/three.js/dev/build/three.module.js';
        import { OrbitControls } from 'https://unpkg.com/three/examples/jsm/controls/OrbitControls.js';
        import { BasisTextureLoader } from 'https://unpkg.com/three/examples/jsm/loaders/BasisTextureLoader.js';
        import { GLTFLoader } from 'https://unpkg.com/three/examples/jsm/loaders/GLTFLoader.js';
        import { VRButton } from 'https://unpkg.com/three/examples/jsm/webxr/VRButton.js';
        import { XRControllerModelFactory } from 'https://unpkg.com/three/examples/jsm/webxr/XRControllerModelFactory.js';

        let controller1, controller2;
        let controllerGrip1, controllerGrip2;

        let raycaster;

        const intersected = [];
        const tempMatrix = new THREE.Matrix4();

        let group;

        const canvas = document.querySelector('#c');
        const renderer = new THREE.WebGLRenderer({canvas, antialias: true});
        // let renderer = new THREE.WebGLRenderer({antialias: true});
        // renderer.setPixelRatio(window.devicePixelRatio);
        // renderer.setSize(window.innerWidth, window.innerHeight);
        // Turn on VR support
        renderer.xr.enabled = true;
        // renderer.outputEncoding = THREE.sRGBEncoding;
        // renderer.outputEncoding = THREE.GammaEncoding;
        // renderer.outputEncoding = THREE.RGBEEncoding;
        // renderer.outputEncoding = THREE.LogLuvEncoding;
        // renderer.outputEncoding = THREE.RGBM7Encoding;
        // renderer.outputEncoding = THREE.RGBM16Encoding;
        // renderer.outputEncoding = THREE.RGBDEncoding;
        // renderer.outputEncoding = THREE.BasicDepthPacking;
        // renderer.outputEncoding = THREE.RGBADepthPacking;

        renderer.shadowMap.enabled = true;

        document.body.appendChild(VRButton.createButton(renderer));

        const fov = 75;
        const aspect = 2;  // the canvas default
        const near = 0.1;
        const far = 2000;
        const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
        camera.position.set(32,6,0);

        let audioContext = new AudioContext();
        let resonanceAudioScene = new ResonanceAudio(audioContext);

        resonanceAudioScene.output.connect(audioContext.destination);

        let roomDimensions = {
            width: 35.0,
            height: 15.0,
            depth: 35.0,
        };

        let roomMaterials = {
            // Room wall materials
            left: 'concrete-block-coarse',
            right: 'concrete-block-coarse',
            front: 'transparent',
            back: 'transparent',
            // Room floor
            down: 'concrete-block-coarse',
            // Room ceiling
            up: 'concrete-block-coarse',
        };

        resonanceAudioScene.setRoomProperties(roomDimensions, roomMaterials);

        // const listener = new THREE.AudioListener();
        // camera.add( listener );

        const controls = new OrbitControls(camera, canvas);
        controls.target.set(0, 0, 0);
        controls.update();

        const scene = new THREE.Scene();

        {
            const loader = new THREE.TextureLoader();
            const texture = loader.load(
            'textures/skybox.png',
            () => {
                const rt = new THREE.WebGLCubeRenderTarget(texture.image.height);
                rt.fromEquirectangularTexture(renderer, texture);
                scene.background = rt;
            });
        }
        
        var terrainLoader = new GLTFLoader();

        terrainLoader.load(
            // resource URL
            'glb/terrain_new4.glb',
            // called when the resource is loaded
            function ( gltf ) {
                let terrain = gltf.scene;
                terrain.rotation.y = -180;
                // terrain.material = terrainMaterial;
                scene.add( terrain );
                // console.log(terrain.material.map);
            },
            // called while loading is progressing
            function ( xhr ) {
                console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
            },
            // called when loading has errors
            function ( error ) {
                console.log( 'An error happened in the terrain loader' );
            }
        );

        const ppLoader = new GLTFLoader();

        ppLoader.load(
            // resource URL
            // 'glb/pp5.glb',
            'glb/pp_new_with_floor.glb',
            // called when the resource is loaded
            function ( gltf ) {
                let pp = gltf.scene;
                pp.scale.set(1.25,1.25,1.25);
                pp.rotation.y = 35;
                // console.log (pp);
                pp.castShadow = true;
                pp.receiveShadow = true;
                scene.add( pp );
            },
            // called while loading is progressing
            function ( xhr ) {
                console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
            },
            // called when loading has errors
            function ( error ) {
                console.log( 'An error happened in the pp loader' );
            }
        );

        group = new THREE.Group();
        scene.add( group );
        
        var geometry = new THREE.SphereGeometry(0.25,10,10);
            
        var deltaPosition = 5;
        
        let numberOfSources = 12;
        var mesh = [];
        var randomRotation = [];
        var materialColor = [];
        var material = []; 
        var sound = [];
        let initialPosition = new THREE.Vector3(0,2,0);
        let radialDistance = 5;
        var deltaAngle = 2 * Math.PI / numberOfSources;
        var r = 0;
        let indexMat = 0;
        let audioElement = [];
        let audioElementSource = [];
        let emissiveColor = [
            "rgb(182,164,168)",
            "rgb(53,199,238)",
            "rgb(42,147,9)",
            "rgb(115,179,71)",
            "rgb(0,72,185)",
            "rgb(171,135,135)",
            "rgb(102,109,191)",
        ];

        for (let index = 0; index < numberOfSources; index++) {
            // materialColor[index] = new THREE.Color(Math.random(),Math.random(),Math.random());
            // material[index] = new THREE.MeshLambertMaterial({color: materialColor[index]});
            // mesh[index] = new THREE.Mesh(geometry, new THREE.MeshLambertMaterial({color: new THREE.Color(Math.random(),Math.random(),Math.random())}));
            mesh[index] = new THREE.Mesh(geometry, new THREE.MeshPhongMaterial({
                map: new THREE.TextureLoader().load( 'textures/spheres/'+indexMat+'.jpg'),
                // emissive: new THREE.Color(Math.random(),Math.random(),Math.random()),
                emissive: new THREE.Color(emissiveColor[indexMat]),
                emissiveIntensity : 0.5}));
            if (indexMat < 6) {indexMat += 1 } else {indexMat = 1 };
            mesh[index].position.x = initialPosition.x + radialDistance*Math.sin(r);
            mesh[index].position.y = initialPosition.y;
            mesh[index].position.z = initialPosition.z + radialDistance*Math.cos(r);
            r += deltaAngle;
            
            //create a global audio source
            // sound[index] = new THREE.PositionalAudio( listener );
            
            audioElement[index] = document.createElement('audio');
            audioElement[index].src = 'sounds/' + index.toString() + '.mp3';

            audioElementSource[index] = audioContext.createMediaElementSource(audioElement[index]);
            
            sound[index] = resonanceAudioScene.createSource();
            sound[index].rolloff = 'linear';//'logarithmic';
            sound[index].minDistance = 0.5;
            sound[index].maxDistance = 100;
            audioElementSource[index].connect(sound[index].input);

            sound[index].setPosition(mesh[index].position.x, 
                                    mesh[index].position.y, 
                                    mesh[index].position.z);


            // load a sound and set it as the Audio object's buffer
            // var audioLoader = new THREE.AudioLoader();
            // audioLoader.load('sounds/' + index.toString() + '.mp3', function( buffer ) {
            //     sound[index].setBuffer( buffer );
            //     sound[index].setLoop( true );
            //     sound[index].setVolume( 4.0 / numberOfSources );
            //     // sound[index].play();
            // });
           
            // scene.add(mesh[index]);
            // mesh[index].add(sound[index]);
            group.add(mesh[index]);
        };

        // resonanceAudioScene.setListenerPosition(camera.position.x,camera.position.y,camera.position.z);
        window.addEventListener('touchstart click', ( ) => {
            for (let index = 0; index < numberOfSources; index++) {
                audioElement[index].play();
                // sound[index].play();
            }
        });

        // window.addEventListener('touchstart', ( ) => {
        //     for (let index = 0; index < numberOfSources; index++) {
        //         // audioElement[index].play();
        //         sound[index].play();
        //     }
        // });

        // Purple top spot light
        let purpleSpotLight = new THREE.SpotLight(0xA771C0);
        purpleSpotLight.position.set( 0, 150, 0 );
        purpleSpotLight.intensity = 0.75;
        purpleSpotLight.distance = 170;
        purpleSpotLight.angle = Math.PI/2;
        scene.add(purpleSpotLight);

        // Main blue point light
        let bluePointLight = new THREE.PointLight(0x368DF3);
        bluePointLight.position.set( 0, 50, 0 );
        bluePointLight.intensity = 4.5;
        bluePointLight.distance = 200;
        scene.add(bluePointLight);

        // Pavilion blue point light
        let pavPointLight = new THREE.PointLight(0x4B26CF);
        pavPointLight.position.set( -25, 25, -25 );
        pavPointLight.intensity = 1.5;
        pavPointLight.distance = 140;
        scene.add(pavPointLight);

        // grass green point light
        let greenGrassLight = new THREE.PointLight(0x3CD667);
        greenGrassLight.position.set( 125, 15, -50 );
        greenGrassLight.intensity = 5;
        greenGrassLight.distance = 150;
        scene.add(greenGrassLight);


        // VR controller and intersection
        controller1 = renderer.xr.getController( 0 );
        controller1.addEventListener( 'selectstart', onSelectStart );
        controller1.addEventListener( 'selectend', onSelectEnd );
        scene.add( controller1 );

        controller2 = renderer.xr.getController( 1 );
        controller2.addEventListener( 'selectstart', onSelectStart );
        controller2.addEventListener( 'selectend', onSelectEnd );
        scene.add( controller2 );

        const controllerModelFactory = new XRControllerModelFactory();

        controllerGrip1 = renderer.xr.getControllerGrip( 0 );
        controllerGrip1.add( controllerModelFactory.createControllerModel( controllerGrip1 ) );
        scene.add( controllerGrip1 );

        controllerGrip2 = renderer.xr.getControllerGrip( 1 );
        controllerGrip2.add( controllerModelFactory.createControllerModel( controllerGrip2 ) );
        scene.add( controllerGrip2 );

        //

        const tempGeometry = new THREE.BufferGeometry().setFromPoints( [ new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, - 1 ) ] );

        const line = new THREE.Line( tempGeometry );
        line.name = 'line';
        line.scale.z = 5;

        controller1.add( line.clone() );
        controller2.add( line.clone() );

        raycaster = new THREE.Raycaster();

        // function onWindowResize() {

        //     camera.aspect = window.innerWidth / window.innerHeight;
        //     camera.updateProjectionMatrix();

        //     renderer.setSize( window.innerWidth, window.innerHeight );

        // }

        function onSelectStart( event ) {

            const controller = event.target;

            const intersections = getIntersections( controller );

            if ( intersections.length > 0 ) {

                const intersection = intersections[ 0 ];

                const object = intersection.object;
                object.material.emissive.b = 1;
                controller.attach( object );

                controller.userData.selected = object;

            }

        }

        function onSelectEnd( event ) {

            const controller = event.target;

            if ( controller.userData.selected !== undefined ) {

                const object = controller.userData.selected;
                object.material.emissive.b = 0;
                group.attach( object );

                controller.userData.selected = undefined;

            }


        }

        function getIntersections( controller ) {

            tempMatrix.identity().extractRotation( controller.matrixWorld );

            raycaster.ray.origin.setFromMatrixPosition( controller.matrixWorld );
            raycaster.ray.direction.set( 0, 0, - 1 ).applyMatrix4( tempMatrix );

            return raycaster.intersectObjects( group.children );

        }

        function intersectObjects( controller ) {

            // Do not highlight when already selected

            if ( controller.userData.selected !== undefined ) return;

            const line = controller.getObjectByName( 'line' );
            const intersections = getIntersections( controller );

            if ( intersections.length > 0 ) {

                const intersection = intersections[ 0 ];

                const object = intersection.object;
                object.material.emissive.r = 1;
                intersected.push( object );

                line.scale.z = intersection.distance;

            } else {

                line.scale.z = 5;

            }

        }

        function cleanIntersected() {

            while ( intersected.length ) {

                const object = intersected.pop();
                object.material.emissive.r = 0;

            }

        }



        function resizeRendererToDisplaySize(renderer) {
            const canvas = renderer.domElement;
            const width = canvas.clientWidth;
            const height = canvas.clientHeight;
            const needResize = canvas.width !== width || canvas.height !== height;
            if (needResize) {
            renderer.setSize(width, height, false);
            }
            return needResize;
        }

        const tempForwardVector = new THREE.Vector3();
        const tempUpVector = new THREE.Vector3();
        // var headPos = renderer.xr.getCamera(camera).getWorldPosition(tempVec);
        // console.log(renderer.xr.getCamera(camera));

        function render(time) {
            time *= 0.001;

            if (resizeRendererToDisplaySize(renderer)) {
            const canvas = renderer.domElement;
            camera.aspect = canvas.clientWidth / canvas.clientHeight;
            camera.updateProjectionMatrix();
            }
            
            cleanIntersected();
            intersectObjects( controller1 );
            intersectObjects( controller2 );

            renderer.render(scene, camera);

            tempForwardVector.set(0, 0, -1);
            tempForwardVector.applyQuaternion(camera.quaternion);

            tempUpVector.set(0, 1, 0);
            tempUpVector.applyQuaternion(camera.quaternion);

            resonanceAudioScene.setListenerOrientation(
                tempForwardVector.x,
                tempForwardVector.y,
                tempForwardVector.z,
                tempUpVector.x,
                tempUpVector.y,
                tempUpVector.z
            );
            
            resonanceAudioScene.setListenerPosition(camera.position.x,camera.position.y,camera.position.z);
            // requestAnimationFrame(render);
        }

        // In WebXR is AnimationLoop instead of AnimationFrame
        renderer.setAnimationLoop( render );
        
        

    </script>
</body>
</html>