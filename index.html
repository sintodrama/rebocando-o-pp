<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="./main.css">
    <script src="https://cdn.jsdelivr.net/npm/resonance-audio/build/resonance-audio.min.js"></script>
</head>
<canvas id="c"></canvas>
<body>
<h1>Rebocando o Pavilh√£o Philips</h1>

    <script type="module">
        // import * as THREE from 'https://cdn.rawgit.com/mrdoob/three.js/dev/build/three.module.js';
        import * as THREE from 'https://threejsfundamentals.org/threejs/resources/threejs/r122/build/three.module.js';
        import {OBJLoader2} from 'https://threejsfundamentals.org/threejs/resources/threejs/r122/examples/jsm/loaders/OBJLoader2.js';
        import {OrbitControls} from 'https://threejsfundamentals.org/threejs/resources/threejs/r122/examples/jsm/controls/OrbitControls.js';
        import { BasisTextureLoader } from 'https://threejsfundamentals.org/threejs/resources/threejs/r122/examples/jsm/loaders/BasisTextureLoader.js';
        import {GLTFLoader} from 'https://threejsfundamentals.org/threejs/resources/threejs/r122/examples/jsm/loaders/GLTFLoader.js';
        import { VRButton } from 'https://unpkg.com/three/examples/jsm/webxr/VRButton.js';

        const canvas = document.querySelector('#c');
        const renderer = new THREE.WebGLRenderer({canvas, antialias: true});
        // let renderer = new THREE.WebGLRenderer({antialias: true});
        // renderer.setPixelRatio(window.devicePixelRatio);
        // renderer.setSize(window.innerWidth, window.innerHeight);
        // Turn on VR support
        renderer.xr.enabled = true;
        // renderer.outputEncoding = THREE.sRGBEncoding;
        // renderer.outputEncoding = THREE.GammaEncoding;
        // renderer.outputEncoding = THREE.RGBEEncoding;
        // renderer.outputEncoding = THREE.LogLuvEncoding;
        // renderer.outputEncoding = THREE.RGBM7Encoding;
        // renderer.outputEncoding = THREE.RGBM16Encoding;
        // renderer.outputEncoding = THREE.RGBDEncoding;
        // renderer.outputEncoding = THREE.BasicDepthPacking;
        // renderer.outputEncoding = THREE.RGBADepthPacking;

        renderer.shadowMap.enabled = true;

        document.body.appendChild(VRButton.createButton(renderer));

        const fov = 75;
        const aspect = 2;  // the canvas default
        const near = 0.1;
        const far = 2000;
        const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
        camera.position.set(32,6,0);

        let audioContext = new AudioContext();
        let resonanceAudioScene = new ResonanceAudio(audioContext);

        resonanceAudioScene.output.connect(audioContext.destination);

        let roomDimensions = {
            width: 35.0,
            height: 15.0,
            depth: 35.0,
        };

        let roomMaterials = {
            // Room wall materials
            left: 'concrete-block-coarse',
            right: 'concrete-block-coarse',
            front: 'transparent',
            back: 'transparent',
            // Room floor
            down: 'concrete-block-coarse',
            // Room ceiling
            up: 'concrete-block-coarse',
        };

        resonanceAudioScene.setRoomProperties(roomDimensions, roomMaterials);

        // const listener = new THREE.AudioListener();
        // camera.add( listener );

        const controls = new OrbitControls(camera, canvas);
        controls.target.set(0, 0, 0);
        controls.update();

        const scene = new THREE.Scene();

        {
            const loader = new THREE.TextureLoader();
            const texture = loader.load(
            'textures/skybox.png',
            () => {
                const rt = new THREE.WebGLCubeRenderTarget(texture.image.height);
                rt.fromEquirectangularTexture(renderer, texture);
                scene.background = rt;
            });
        }
        
        var terrainLoader = new GLTFLoader();

        terrainLoader.load(
            // resource URL
            'glb/terrain_new4.glb',
            // called when the resource is loaded
            function ( gltf ) {

                let terrain = gltf.scene;
                terrain.rotation.y = -180;
                // terrain.material = terrainMaterial;
                scene.add( terrain );
                // console.log(terrain.material.map);
            },
            // called while loading is progressing
            function ( xhr ) {

                console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );

            },
            // called when loading has errors
            function ( error ) {

                console.log( 'An error happened in the terrain loader' );

            }
        );

        const ppLoader = new GLTFLoader();

        ppLoader.load(
            // resource URL
            'glb/pp5.glb',
            // called when the resource is loaded
            function ( gltf ) {

                let pp = gltf.scene;
                pp.scale.set(1.25,1.25,1.25);
                pp.rotation.y = 35;
                console.log (pp);
                scene.add( pp );
            },
            // called while loading is progressing
            function ( xhr ) {

                console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );

            },
            // called when loading has errors
            function ( error ) {

                console.log( 'An error happened in the pp loader' );

            }
        );

        var geometry = new THREE.SphereGeometry(0.25,10,10);
            
        var deltaPosition = 5;
        
        let numberOfSources = 12;
        var mesh = [];
        var randomRotation = [];
        var materialColor = [];
        var material = []; 
        var sound = [];
        let initialPosition = new THREE.Vector3(0,2,0);
        let radialDistance = 5;
        var deltaAngle = 2 * Math.PI / numberOfSources;
        var r = 0;
        let indexMat = 0;
        let audioElement = [];
        let audioElementSource = [];

        for (let index = 0; index < numberOfSources; index++) {
            // materialColor[index] = new THREE.Color(Math.random(),Math.random(),Math.random());
            // material[index] = new THREE.MeshLambertMaterial({color: materialColor[index]});
            // mesh[index] = new THREE.Mesh(geometry, new THREE.MeshLambertMaterial({color: new THREE.Color(Math.random(),Math.random(),Math.random())}));
            mesh[index] = new THREE.Mesh(geometry, new THREE.MeshPhongMaterial({
                map: new THREE.TextureLoader().load( 'textures/spheres/'+indexMat+'.jpg'),
                emissive: new THREE.Color(Math.random(),Math.random(),Math.random()),
                emissiveIntensity : 0.05}));
            if (indexMat < 6) {indexMat += 1 } else {indexMat = 1 };
            mesh[index].position.x = initialPosition.x + radialDistance*Math.sin(r);
            mesh[index].position.y = initialPosition.y;
            mesh[index].position.z = initialPosition.z + radialDistance*Math.cos(r);
            r += deltaAngle;
            
            //create a global audio source
            // sound[index] = new THREE.PositionalAudio( listener );
            
            audioElement[index] = document.createElement('audio');
            audioElement[index].src = 'sounds/' + index.toString() + '.mp3';

            audioElementSource[index] = audioContext.createMediaElementSource(audioElement[index]);
            
            sound[index] = resonanceAudioScene.createSource();
            sound[index].rolloff = 'linear';//'logarithmic';
            sound[index].minDistance = 1;
            sound[index].maxDistance = 3;
            audioElementSource[index].connect(sound[index].input);

            sound[index].setPosition(mesh[index].position.x, 
                                    mesh[index].position.y, 
                                    mesh[index].position.z);

            // audioElement[index].play();

            // load a sound and set it as the Audio object's buffer
            // var audioLoader = new THREE.AudioLoader();
                    
            // audioLoader.load('sounds/' + index.toString() + '.mp3', function( buffer ) {
            //     sound[index].setBuffer( buffer );
            //     sound[index].setLoop( true );
            //     sound[index].setVolume( 2.0 / numberOfSources );
            //     sound[index].play();
            // });
           
            scene.add(mesh[index]);
            // mesh[index].add(sound[index]);
        };
        resonanceAudioScene.setListenerPosition(camera.position.x,camera.position.y,camera.position.z);

        window.addEventListener('click', ( ) => {
            for (let index = 0; index < numberOfSources; index++) {
                audioElement[index].play();
            }
        });

        // Purple top spot light
        let purpleSpotLight = new THREE.SpotLight(0xA771C0);
        purpleSpotLight.position.set( 0, 150, 0 );
        purpleSpotLight.intensity = 0.75;
        purpleSpotLight.distance = 170;
        purpleSpotLight.angle = Math.PI/2;
        scene.add(purpleSpotLight);

        // Main blue point light
        let bluePointLight = new THREE.PointLight(0x368DF3);
        bluePointLight.position.set( 0, 50, 0 );
        bluePointLight.intensity = 4.5;
        bluePointLight.distance = 200;
        scene.add(bluePointLight);

        // Pavilion blue point light
        let pavPointLight = new THREE.PointLight(0x4B26CF);
        pavPointLight.position.set( -25, 25, -25 );
        pavPointLight.intensity = 1.5;
        pavPointLight.distance = 140;
        scene.add(pavPointLight);

        // grass green point light
        let greenGrassLight = new THREE.PointLight(0x3CD667);
        greenGrassLight.position.set( 125, 15, -50 );
        greenGrassLight.intensity = 5;
        greenGrassLight.distance = 150;
        scene.add(greenGrassLight);


        // const directionalLight = new THREE.DirectionalLight( "rgb(39, 90, 228)", 0.5 );
        // scene.add( directionalLight );

        function resizeRendererToDisplaySize(renderer) {
            const canvas = renderer.domElement;
            const width = canvas.clientWidth;
            const height = canvas.clientHeight;
            const needResize = canvas.width !== width || canvas.height !== height;
            if (needResize) {
            renderer.setSize(width, height, false);
            }
            return needResize;
        }

        function render(time) {
            time *= 0.001;

            if (resizeRendererToDisplaySize(renderer)) {
            const canvas = renderer.domElement;
            camera.aspect = canvas.clientWidth / canvas.clientHeight;
            camera.updateProjectionMatrix();
            }
            
            renderer.render(scene, camera);
            resonanceAudioScene.setListenerPosition(camera.position.x,camera.position.y,camera.position.z);
            // requestAnimationFrame(render);
        }

        // In WebXR is AnimationLoop instead of AnimationFrame
        renderer.setAnimationLoop( render );
        
        

    </script>
</body>
</html>