<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="./main.css">
</head>
<canvas id="c"></canvas>
<body>
<h1>Rebocando o Pavilh√£o Philips</h1>

    <script type="module">
        // import * as THREE from 'https://cdn.rawgit.com/mrdoob/three.js/dev/build/three.module.js';
        import * as THREE from 'https://threejsfundamentals.org/threejs/resources/threejs/r122/build/three.module.js';
        import {OBJLoader2} from 'https://threejsfundamentals.org/threejs/resources/threejs/r122/examples/jsm/loaders/OBJLoader2.js';
        import {OrbitControls} from 'https://threejsfundamentals.org/threejs/resources/threejs/r122/examples/jsm/controls/OrbitControls.js';
        import { BasisTextureLoader } from 'https://threejsfundamentals.org/threejs/resources/threejs/r122/examples/jsm/loaders/BasisTextureLoader.js';
        import {GLTFLoader} from 'https://threejsfundamentals.org/threejs/resources/threejs/r122/examples/jsm/loaders/GLTFLoader.js';

        const canvas = document.querySelector('#c');
        const renderer = new THREE.WebGLRenderer({canvas});
        renderer.outputEncoding = THREE.sRGBEncoding;
        // renderer.outputEncoding = THREE.GammaEncoding;
        // renderer.outputEncoding = THREE.RGBEEncoding;
        // renderer.outputEncoding = THREE.LogLuvEncoding;
        // renderer.outputEncoding = THREE.RGBM7Encoding;
        // renderer.outputEncoding = THREE.RGBM16Encoding;
        // renderer.outputEncoding = THREE.RGBDEncoding;
        // renderer.outputEncoding = THREE.BasicDepthPacking;
        // renderer.outputEncoding = THREE.RGBADepthPacking;

        const fov = 75;
        const aspect = 2;  // the canvas default
        const near = 0.1;
        const far = 2000;
        const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
        camera.position.set(52,6,-30);

        const listener = new THREE.AudioListener();
        camera.add( listener );

        const controls = new OrbitControls(camera, canvas);
        controls.target.set(0, 0, 0);
        controls.update();

        const scene = new THREE.Scene();

        {
            const loader = new THREE.TextureLoader();
            const texture = loader.load(
            'textures/skybox.png',
            () => {
                const rt = new THREE.WebGLCubeRenderTarget(texture.image.height);
                rt.fromEquirectangularTexture(renderer, texture);
                scene.background = rt;
            });
        }
        

        const terrainTextureLoader = new THREE.TextureLoader();
        var terrainMap = terrainTextureLoader.load( 'textures/terrain_cliff_baked.png');
        // If texture is used for color information, set colorspace.
        terrainMap.encoding = THREE.sRGBEncoding;
        // UVs use the convention that (0, 0) corresponds to the upper left corner of a texture.
        terrainMap.flipY = false;
        const terrainMaterial = new THREE.MeshPhongMaterial({map: terrainMap}); 

        var terrainLoader = new GLTFLoader();

        terrainLoader.load(
            // resource URL
            'glb/terrain_new4.glb',
            // called when the resource is loaded
            function ( gltf ) {

                let terrain = gltf.scene;
                terrain.rotation.y = -180;
                // terrain.material = terrainMaterial;
                scene.add( terrain );
                // console.log(terrain.material.map);
            },
            // called while loading is progressing
            function ( xhr ) {

                console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );

            },
            // called when loading has errors
            function ( error ) {

                console.log( 'An error happened in the terrain loader' );

            }
        );

        const ppLoader = new GLTFLoader();

        ppLoader.load(
            // resource URL
            'glb/pp5.glb',
            // called when the resource is loaded
            function ( gltf ) {

                let pp = gltf.scene;
                pp.scale.set(1.25,1.25,1.25);
                pp.rotation.y = 35;
                scene.add( pp );
            },
            // called while loading is progressing
            function ( xhr ) {

                console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );

            },
            // called when loading has errors
            function ( error ) {

                console.log( 'An error happened in the pp loader' );

            }
        );

        var geometry = new THREE.SphereGeometry(0.25,10,10);
            
        var deltaPosition = 5;
        
        let numberOfSources = 12;
        var mesh = [];
        var randomRotation = [];
        var materialColor = [];
        var material = []; 
        var sound = [];
        let initialPosition = new THREE.Vector3(0,2,0);
        let radialDistance = 5;
        var deltaAngle = 2 * Math.PI / numberOfSources;
        var r = 0;
        let indexMat = 0;
        for (let index = 0; index < numberOfSources; index++) {
            // materialColor[index] = new THREE.Color(Math.random(),Math.random(),Math.random());
            // material[index] = new THREE.MeshLambertMaterial({color: materialColor[index]});
            // mesh[index] = new THREE.Mesh(geometry, new THREE.MeshLambertMaterial({color: new THREE.Color(Math.random(),Math.random(),Math.random())}));
            mesh[index] = new THREE.Mesh(geometry, new THREE.MeshPhongMaterial({
                map: new THREE.TextureLoader().load( 'textures/spheres/'+indexMat+'.jpg'),
                emissive: new THREE.Color(Math.random(),Math.random(),Math.random()),
                emissiveIntensity : 0.05}));
            if (indexMat < 6) {indexMat += 1 } else {indexMat = 1 };
            mesh[index].position.x = initialPosition.x + radialDistance*Math.sin(r);
            mesh[index].position.y = initialPosition.y;
            mesh[index].position.z = initialPosition.z + radialDistance*Math.cos(r);
            r += deltaAngle;
            
            //create a global audio source
            sound[index] = new THREE.PositionalAudio( listener );

            // load a sound and set it as the Audio object's buffer
            var audioLoader = new THREE.AudioLoader();
                    
            audioLoader.load('sounds/' + index.toString() + '.mp3', function( buffer ) {
                sound[index].setBuffer( buffer );
                sound[index].setLoop( true );
                sound[index].setVolume( 2.0 / numberOfSources );
                sound[index].play();
            });
           
            scene.add(mesh[index]);
            mesh[index].add(sound[index]);
        };

        var light = [];
        var lightPosition = [
                    new THREE.Vector3(25,20,50),
                    new THREE.Vector3(80,20,-50),
                    new THREE.Vector3(125,20,50),
                    new THREE.Vector3(-125,20,-50)
                    ];
        let lightIntensity = 0.05;
        var lightColor = [
                    new THREE.Color('skyblue'),
                    new THREE.Color('skyblue'),
                    new THREE.Color('skyblue'),
                    new THREE.Color('skyblue')
                    ];
     
        for (let index = 0; index < lightPosition.length; index++) {
            light[index] = new THREE.PointLight(lightColor[index],lightIntensity,1000);
            light[index].position.set(lightPosition[index].x,lightPosition[index].y,lightPosition[index].z);
            scene.add(light[index]);
        }

        const directionalLight = new THREE.DirectionalLight( 'blue', 0.5 );
        scene.add( directionalLight );

        function resizeRendererToDisplaySize(renderer) {
            const canvas = renderer.domElement;
            const width = canvas.clientWidth;
            const height = canvas.clientHeight;
            const needResize = canvas.width !== width || canvas.height !== height;
            if (needResize) {
            renderer.setSize(width, height, false);
            }
            return needResize;
        }

        function render(time) {
            time *= 0.001;

            if (resizeRendererToDisplaySize(renderer)) {
            const canvas = renderer.domElement;
            camera.aspect = canvas.clientWidth / canvas.clientHeight;
            camera.updateProjectionMatrix();
            }
            renderer.render(scene, camera);

            requestAnimationFrame(render);
        }

        requestAnimationFrame(render);

    </script>
</body>
</html>